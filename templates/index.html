<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Circle Accuracy</title>
<style>
/* --- 색상 토큰: 라이트/다크 공통 키 --- */
:root{
  --bg:#ffffff;        /* 페이지 배경 */
  --fg:#111111;        /* 본문 텍스트/선 */
  --muted:#666a73;     /* 보조 텍스트 */
  --line:#dadde2;      /* 테두리/구분선 */
  --target:#9aa0a6;    /* 목표 원(회색) */
  --stroke:#111111;    /* 사용자가 그리는 선 */
  --canvas:#ffffff;    /* 캔버스 배경 */
  --brand:#111111;
  --btn-fg:#ffffff;
  --btn-bg:#111111;
}

/* 시스템 다크모드 대응 */
@media (prefers-color-scheme: dark){
  :root{
    --bg:#0b0c0f;
    --fg:#f2f4f8;
    --muted:#a7adb6;
    --line:#2a2f37;
    --target:#8a9099;
    --stroke:#e9ecf1;
    --canvas:#0f1115;
    --brand:#f2f4f8;
    --btn-fg:#0b0c0f;
    --btn-bg:#f2f4f8;
  }
}

*{ box-sizing:border-box; }
body{
  margin:0; background:var(--bg); color:var(--fg);
  font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
}

/* 상단 헤더 */
header{
  padding:14px 20px; border-bottom:1px solid var(--line);
  display:flex; justify-content:center; align-items:center;
}
.brand{ font-weight:800; letter-spacing:.5px; color:var(--brand); }

/* 공통 패널 */
main{ padding:20px; display:grid; gap:20px; max-width:960px; margin:0 auto; }
.panel{ border:1px solid var(--line); border-radius:16px; padding:16px; background:transparent; }

/* 캔버스 */
#canvasWrap{ display:flex; justify-content:center; touch-action:none; }
#draw{
  border:1px solid var(--line); border-radius:16px;
  background:var(--canvas); max-width:100%; display:block;
}

/* 점수/시간 */
.meta{ display:flex; gap:40px; justify-content:center; align-items:baseline; flex-wrap:wrap; }
.scoreBox{ font-size:44px; font-weight:800; letter-spacing:.5px; }
.timeBox{ font-size:20px; color:var(--muted); }

/* 안내문 */
.instructions{ color:var(--muted); font-size:15px; line-height:1.6; margin-top:8px; }
.instructions ul{ margin:8px 0 0 20px; padding:0; }
.instructions li{ margin:6px 0; }

/* 중앙 하단 고정 리셋 버튼 (태블릿 접근성 강화) */
#fabReset{
  position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
  z-index:1000; padding:14px 18px; border-radius:999px;
  border:1px solid var(--btn-bg); background:var(--btn-bg); color:var(--btn-fg);
  font-weight:700; letter-spacing:.3px; cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,.18);
}
#fabReset:active{ transform:translateX(-50%) translateY(1px); }

/* 작은 화면에서 글자 살짝 키움 */
@media (max-width:420px){
  .scoreBox{ font-size:38px; }
}
</style>
</head>
<body>
<header>
  <div class="brand">CIRCLE · ACCURACY</div>
</header>

<!-- 중앙 하단 접근성 좋은 RESET 버튼 -->
<button id="fabReset">RESET</button>

<main>
  <div class="panel">
    <div id="canvasWrap"><canvas id="draw" width="640" height="640"></canvas></div>
    <div class="instructions">
      <ul>
        <li><strong>회색 목표 원을 따라 한 바퀴</strong>를 그려 완성하세요. (출발점 근처에 도달하면 자동 종료)</li>
        <li><strong>그리기를 시작하면 타이머가 시작</strong>됩니다.</li>
        <li><strong>연구 목표</strong>: 그리기 <strong>시간</strong>과 <strong>정확도(표준편차)</strong>의 상관관계를 분석합니다.</li>
      </ul>
    </div>
  </div>

  <div class="panel meta">
    <div class="scoreBox">SCORE <span id="score">—</span> / 100</div>
    <div class="timeBox">TIME <span id="duration">0.00</span>s</div>
  </div>
</main>

<script>
/* ===== 완성 판정(출발점 재도달) 파라미터 ===== */
const COMPLETE_REV_THRESH   = 0.90;   // 최소 회전수 (완화)
const COMPLETE_DIST_MIN_PX  = 18;     // 최소 픽셀 거리 (완화)
const COMPLETE_DIST_SCALE   = 0.10;   // R에 대한 비율 (완화)

/* ===== DOM ===== */
const canvas = document.getElementById('draw');
const ctx = canvas.getContext('2d');
const resetBtn = document.getElementById('fabReset');
const scoreSpan = document.getElementById('score');
const durationSpan = document.getElementById('duration');

/* 서버가 주입하는 목표 반지름 */
const TARGET_R = {{ target_r }};

/* 상태 */
let cx, cy, drawing=false, started=false, finished=false;
let points=[], t0=null, startPt=null, lastAngle=null, cumulativeAngle=0;

/* CSS 변수 읽기 */
function cssVar(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

function layout(){
  const size = Math.min(window.innerWidth*0.92, window.innerHeight*0.70, 720);
  canvas.width = Math.max(320, Math.floor(size));
  canvas.height = canvas.width;
  cx = Math.floor(canvas.width/2);
  cy = Math.floor(canvas.height/2);
  drawStatic();
}

function drawStatic(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 중심점 (1개)
  ctx.fillStyle = cssVar('--fg');
  ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();

  // 목표 원(회색, 점선)
  ctx.strokeStyle = cssVar('--target'); ctx.lineWidth = 2; ctx.setLineDash([6,4]);
  ctx.beginPath(); ctx.arc(cx, cy, TARGET_R, 0, Math.PI*2); ctx.stroke();
  ctx.setLineDash([]);
}

function resetAll(){
  drawing=false; started=false; finished=false;
  points=[]; t0=null; startPt=null; lastAngle=null; cumulativeAngle=0;
  scoreSpan.textContent='—'; durationSpan.textContent='0.00';
  drawStatic();
}

function pointerPos(e){
  const r = canvas.getBoundingClientRect();
  const x = (e.clientX ?? (e.touches && e.touches[0].clientX)) - r.left;
  const y = (e.clientY ?? (e.touches && e.touches[0].clientY)) - r.top;
  return {x,y};
}

function begin(e){
  e.preventDefault();
  const p = pointerPos(e);
  if(!started){
    started = true;
    t0 = performance.now();          // ← 그리기 시작 = 타이머 시작
    startPt = p;
    lastAngle = Math.atan2(p.y - cy, p.x - cx);
  }
  drawing = true;
  ctx.strokeStyle = cssVar('--stroke'); ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(p.x, p.y);
  points = [{x:p.x, y:p.y, t:performance.now()}];
}

function move(e){
  if(!drawing || finished) return;
  e.preventDefault();
  const p = pointerPos(e);
  ctx.lineTo(p.x, p.y); ctx.stroke();
  points.push({x:p.x, y:p.y, t:performance.now()});

  // 누적 회전각(unwrapped)
  const ang = Math.atan2(p.y - cy, p.x - cx);
  let d = ang - lastAngle;
  while (d <= -Math.PI) d += Math.PI*2;
  while (d >  Math.PI) d -= Math.PI*2;
  cumulativeAngle += d;
  lastAngle = ang;

  // 완성 조건(완화 임계값)
  const revol = Math.abs(cumulativeAngle) / (Math.PI*2);
  const dist  = Math.hypot(p.x - startPt.x, p.y - startPt.y);
  const nearStart = dist <= Math.max(COMPLETE_DIST_MIN_PX, TARGET_R * COMPLETE_DIST_SCALE);
  if (revol >= COMPLETE_REV_THRESH && nearStart) finish();
}

function end(){ drawing = false; }

function finish(){
  if (finished) return;
  finished = true;
  const elapsed = (performance.now() - t0) / 1000;

  fetch('/submit',{
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({
      points, center:{x:cx,y:cy},
      duration_s:elapsed, client_w:window.innerWidth, client_h:window.innerHeight
    })
  }).then(r=>r.json()).then(res=>{
    scoreSpan.textContent    = res.score;
    durationSpan.textContent = res.duration_s.toFixed(2);
  }).catch(()=>{
    // 저장 비활성화 모드 등 예외에서도 시간은 표시
    durationSpan.textContent = elapsed.toFixed(2);
  });
}

/* 이벤트 바인딩 */
canvas.addEventListener('pointerdown', begin);
canvas.addEventListener('pointermove', move);
canvas.addEventListener('pointerup',   end);
canvas.addEventListener('pointerleave',end);

canvas.addEventListener('touchstart', e=>begin(e), {passive:false});
canvas.addEventListener('touchmove',  e=>move(e),  {passive:false});
canvas.addEventListener('touchend',   e=>end(e),   {passive:false});

resetBtn.addEventListener('click', resetAll);
window.addEventListener('resize', layout);
window.addEventListener('orientationchange', layout);

/* 초기 렌더 */
layout();
resetAll();
</script>
</body>
</html>
